/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.tantech.cards.search;

import com.tantech.cards.db.Card;
import com.tantech.cards.db.CardRepository;
import com.tantech.cards.db.OwnedCard;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.apache.lucene.search.Sort;
import org.apache.lucene.search.SortedSetSortField;
import org.hibernate.search.jpa.FullTextEntityManager;
import org.hibernate.search.jpa.Search;
import org.hibernate.search.query.dsl.BooleanJunction;
import org.hibernate.search.query.dsl.QueryBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 *
 * @author pfholden
 */

@Service
@Transactional

public class CardSearchService {
    @Autowired // This means to get the bean called cardRepository
	           // Which is auto-generated by Spring, we will use it to handle the data
    private CardRepository cardRepository;
//    @Autowired
//    private MTGSetRepository setRepository;
//    @Autowired
//    private OwnedCardRepository ownedRepository;
    
    @PersistenceContext
    private EntityManager entityManager;
    
//    private SessionFactory sessionFactory = entityManager.unwrap(SessionFactory.class);
    
    
    
    
    public List<Card> searchCards(String name, String text, String type, String colors, String setname) {

        FullTextEntityManager fullTextEntityManager 
            = Search.getFullTextEntityManager(entityManager);

        QueryBuilder queryBuilder = fullTextEntityManager.getSearchFactory() 
            .buildQueryBuilder()
            .forEntity(Card.class)
            .get();
        org.apache.lucene.search.Sort sort = new Sort(new SortedSetSortField("sortName", false));

        BooleanJunction mj = queryBuilder.bool();
        boolean first = true;
        if (!name.isEmpty()) {
            if (first) {
                mj = queryBuilder.bool().must(queryBuilder.simpleQueryString()
                                .onField("name").matching(name).createQuery());
                first = false;
            }
            else mj.must(queryBuilder.simpleQueryString()
                                .onField("name").matching(name).createQuery());
            System.out.println("Added name: "+name);
        }
        if (!text.isEmpty()) {
            if (first) {
                mj = queryBuilder.bool().must(queryBuilder.simpleQueryString()
                                .onField("text").matching(text).createQuery());
                first = false;
            }
            else mj.must(queryBuilder.simpleQueryString()
                                .onField("text").matching(text).createQuery());
            System.out.println("Added text: "+text);
        }
        if (!type.isEmpty()) {
            if (first) {
                mj = queryBuilder.bool().must(queryBuilder.simpleQueryString()
                                .onField("type").matching(type).createQuery());
                first = false;
            }
            else mj.must(queryBuilder.simpleQueryString()
                                .onField("type").matching(type).createQuery());
            System.out.println("Added type: "+type);
        }
        if (!colors.isEmpty()) {
            if (first) {
                mj = queryBuilder.bool().must(queryBuilder.simpleQueryString()
                                .onField("colors").matching(colors).createQuery());
                first = false;
            }
            else mj.must(queryBuilder.simpleQueryString()
                                .onField("colors").matching(colors).createQuery());
            System.out.println("Added colors: "+colors);
        }
        if (!setname.isEmpty()) {
            if (first) {
                mj = queryBuilder.bool().must(queryBuilder.simpleQueryString()
                                .onField("setname").matching(setname).createQuery());
                first = false;
            }
            else mj.must(queryBuilder.simpleQueryString()
                                .onField("setname").matching(setname).createQuery());
            System.out.println("Added setname: "+setname);
        }
        
        //If first still set all query values are empty. Just return all cards.
        if (first){
            mj.must(queryBuilder.all().createQuery());
        }

        org.hibernate.search.jpa.FullTextQuery jpaQuery
            = fullTextEntityManager.createFullTextQuery(mj.createQuery(), Card.class);

        jpaQuery.setSort(sort);

        List<Card> cardLst = jpaQuery.getResultList();

//          Remove duplicate named cards
//          Need to order by release date so latest printing is first.
        Set<String> nameSet = new HashSet<>();
        List<Card> uniqueCardLst = cardLst.stream().filter(e -> nameSet.add(e.getName()))
                    .collect(Collectors.toList());

//        System.out.println("");
//        System.out.println("name,text,set,type,colors,mana cost,power,toughness");
//        for(Card card:uniqueCardLst){
////                System.out.println("Card name: "+card.getName());
////                System.out.println("Card text: "+card.getText());
////                System.out.println("Card set: "+card.getMtgSet().getName());
////                System.out.println("Card type: "+card.getType());
////                System.out.println("Colors: "+card.getColors());
////                System.out.println("Mana cost: "+card.getManaCost());
////                System.out.println("Power/Toughness: "+card.getPower()+"/"+card.getToughness());
////                System.out.println("");
//            System.out.println("\""+card.getName()+"\",\""+card.getText()+"\",\""+card.getMtgSet().getName()+"\",\""+ 
//                card.getType()+"\",\""+card.getColors()+"\","+card.getManaCost()+","+card.getPower()+","+card.getToughness());
//        } 
//        System.out.println("Total: "+uniqueCardLst.size());

        return uniqueCardLst;
    }

     public List<OwnedCard> searchOwnedCards(String name, String text, String type, String colors, String setname) {
 
        FullTextEntityManager fullTextEntityManager 
            = Search.getFullTextEntityManager(entityManager);

        QueryBuilder queryBuilder = fullTextEntityManager.getSearchFactory() 
            .buildQueryBuilder()
            .forEntity(OwnedCard.class)
            .get();

        BooleanJunction mj = queryBuilder.bool();
        boolean first = true;
        
        if (!name.isEmpty()) {
            mj.must(queryBuilder.simpleQueryString()
                                .onField("cardMaster.name").matching(name).createQuery());
            first = false;
            System.out.println("Added name: "+name);
        }
        if (!text.isEmpty()) {
            mj.must(queryBuilder.simpleQueryString()
                                .onField("cardMaster.text").matching(text).createQuery());
            first = false;
            System.out.println("Added text: "+text);
        }
        if (!type.isEmpty()) {
            mj.must(queryBuilder.simpleQueryString()
                                .onField("cardMaster.type").matching(type).createQuery());
            first = false;
            System.out.println("Added type: "+type);
        }
        if (!colors.isEmpty()) {
            mj.must(queryBuilder.simpleQueryString()
                                .onField("cardMaster.colors").matching(colors).createQuery());
            first = false;
            System.out.println("Added colors: "+colors);
        }
        if (!setname.isEmpty()) {
            mj.must(queryBuilder.simpleQueryString()
                                .onField("setName.name").matching(setname).createQuery());
            first = false;
            System.out.println("Added setname: "+setname);
        }

        //If first still set all query values are empty. Just return all cards.
        if (first){
            mj.must(queryBuilder.all().createQuery());
        }
        
        org.hibernate.search.jpa.FullTextQuery jpaQuery
            = fullTextEntityManager.createFullTextQuery(mj.createQuery(), OwnedCard.class);

        org.apache.lucene.search.Sort sort = new Sort(new SortedSetSortField("cardMaster.sortName", false));

        jpaQuery.setSort(sort);

        List<OwnedCard> cardLst = jpaQuery.getResultList();
        
//        for(OwnedCard card:cardLst){
//            System.out.println("Name: "+card.getCardMaster().getName());
//            System.out.println("Text: "+card.getCardMaster().getText());
//            System.out.println("Card type: "+card.getCardMaster().getType());
//            System.out.println("Mana Cost: "+card.getCardMaster().getManaCost());
//            System.out.println("Colors: "+card.getCardMaster().getColors());
//            System.out.println("Power/Toughness: "+card.getCardMaster().getPower()+"/"+card.getCardMaster().getToughness());
//            System.out.println("Set: "+card.getSetName().getName());
//            System.out.println("Condition: "+card.getCardCondition());
//            System.out.println("Location: "+card.getCardLocation());
//            System.out.println("Stars: "+card.getCardStars());
//            System.out.println("Price paid: "+card.getPricePaid());
//            System.out.println("");
//        }
        
        return cardLst;
     }
    
    public String reloadIndex() throws InterruptedException {
       
        FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(entityManager);

        fullTextEntityManager.createIndexer().start();

        return "Indexing Completed";
    }
    
    public java.util.List<String> searchNames(){
        return(cardRepository.findByAsArrayAndSort(new org.springframework.data.domain.Sort("name")));
    }
    
}
